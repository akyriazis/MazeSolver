Student Name #1: TODO: Alex Kyriazis
Student ugrad login #1: TODO: s3x9a

Student Name #2: TODO: Lin Xiang
Student ugrad login #2: TODO: o8a0b

Team name (for fun!): TODO:

Acknowledgment that you understand and have followed the course's
collaboration policy
(http://www.ugrad.cs.ubc.ca/~cs221/current/syllabus.shtml#conduct):

TODO: [[Put your names here again as a signature]] Lin Xiang, Alex Kyriazis

TODO: submit using: make handin-proj1

----------------------------------------------------------------------

Approximate hours on project: TODO:

----------------------------------------------------------------------

For teams, rough breakdown of work: TODO:

----------------------------------------------------------------------

Acknowledgment of assistance: TODO:

----------------------------------------------------------------------

Questions:

For the explanations, generally a sentence or two should be enough.
Type your answers directly in this file.


1.  Edit solve.cpp to use either of your queue classes to solve Mazes
1, 2, 3, and 4.  Set a large enough delay in the solveMaze function
(like 200000) to watch what's happening.  Do you see why this is called
breadth-first search (BFS)?  How many steps long were your solutions?
How does this compare with DFS?

TODO: 
Maze 1 58 steps, maze 2 14 steps, maze 3 5 steps, maze 4 90 steps
it is called bfs is beacuse it go through all childrens of current node before it goes deeply.
dfs will go through one entrie child branch of current node before it goes to next child of current node 

2.  Try to solve the blank Sudoku board using your ArrayQueue
and LinkedListQueue classes.  What happens?  Why?

TODO:
when dealing with blank sudoku board, both array queue and linkedlistqueue will take very long time, around couple hours
because both of them need to fill in all the possible numbers, which will lead to 9^81 solutions which is quiet huge.

3.  Switch to the medium-difficulty Sudoku problem, and comment
out the delay and the print statements in the solveMaze function.
How long does it take to solve the puzzle using your ArrayQueue
class?  Using your LinkedListQueue class?  Is the difference big?

TODO:
ArrayQueue 50 steps, LinkedListQueue 50 steps, not big difference, linkedlistqueue and arrayqueue is just the way it store and connect data, efficient will depend more on the alogrithom it use. In this case, both of them are bfs, so the steps shouldn't have big difference

4.  Edit solve.cpp to switch to the 4x4 and then 5x5 slider puzzles.
Make sure to comment out the delay and print statements in the solveMaze
function.  How long does it take to solve these puzzles with your
HeapPriorityQueue versus my UnsortedPriorityQueue?  For most students,
mine will be faster?  Why might that happen?  Are the asymptotic
runtimes for the heap versus the unsorted array wrong?

TODO:
4X4 HeapPriorityQueue: 158 steps, UnsortedPriorityQueue 180 steps
5X5 HeapPriorityQueue: 702 steps, UnsortedPriorityQueue 396 steps
----------------------------------------------------------------------

We will be checking your implementations of ArrayQueue, LinkedListQueue,
and HeapPriorityQueue.
